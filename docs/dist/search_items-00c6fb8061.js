searchNodes=[{"doc":"","ref":"AdventOfCode.Enum.html","title":"AdventOfCode.Enum","type":"module"},{"doc":"","ref":"AdventOfCode.Enum.html#intersect/2","title":"AdventOfCode.Enum.intersect/2","type":"function"},{"doc":"","ref":"AdventOfCode.Enum.html#unordored_equal?/2","title":"AdventOfCode.Enum.unordored_equal?/2","type":"function"},{"doc":"","ref":"AdventOfCode.String.html","title":"AdventOfCode.String","type":"module"},{"doc":"","ref":"AdventOfCode.String.html#downcase?/1","title":"AdventOfCode.String.downcase?/1","type":"function"},{"doc":"","ref":"AdventOfCode.String.html#upcase?/1","title":"AdventOfCode.String.upcase?/1","type":"function"},{"doc":"Let's go for our first assignment ! We need to help this pool elves by reading an input file, parsing values insides it, and looping through while keeping trace of how many times n+1 is greater than n. Preparing input Reading a file is fairly easy : File.read!(&quot;input&quot;) does wonderfully the job. My first try was with File.read (note the absence of ! at the end of read), but I received a tuple. Maybe it's something rust-like, I don't know at this point and I don't need to know for the first exercice, so whatever. Now I have my file, I need to cut and cast each line to an int. In search of how to do it, I discovered Elixir use pipes, and I really love pipes ! Good point for you Elixir. This time again, Integer.parse gives me a tuple. I will need to read the API for clearing this point. File . read! ( &quot;input&quot; ) |&gt; String . split |&gt; Enum . map ( fn n -&gt; { v , _ } = Integer . parse ( n ) ; v end ) Looping without loops You want loops ? Well, in elixir there is none. NO. LOOPS. It is not the first time I find myself without loops (TI-BASIC and Eve don't have any) but I still have the strange impression to be Samus, ripped of all my goodies during my first room exploration. Well, I lost my looping powers, but y still have my Power beam recursion ! I read the Enumerable.reduce implementation and solved the problem swiftly. Part2 is roughly the same and was done in seconds. First day : conclusion Elixir gives us pretty interesting things, like multi-signatures functions, guards, and list/tuple destructuring (which I tend to overuse in Typescript). It's my first time seeing pipes outside bash, and I must say it's a instant love. This single thing can easily remove intermediary values and this(kind(of(stupid(&quot;things&quot;)))). We don't have loops, but writing recursive functions is as easy as writing loops, and it seem easier to debug.","ref":"Day01.html","title":"Day01","type":"module"},{"doc":"Yesterday we have read the scanner, now we need to nearn how to pilote the submarine. For that, we will need to parse each line as a couple of values, and reducing this new array. Easy enough I guess. Elixir scopes I don't know how I've not stumbled on this topic yesterday, but scopes in elixir are strict. I mean, REALLY strict : It's not possible to update a variable inside a if. Without this problem I could have used a case, but I need to use 3 ifs instead. hPos = if command_type == &quot;forward&quot; , do : hPos + value , else : hPos depth = if command_type == &quot;down&quot; , do : depth + value , else : depth depth = if command_type == &quot;up&quot; , do : depth - value , else : depth Outside of this problem of scopes nothing much to see here, and the second part is globally the same.","ref":"Day02.html","title":"Day02","type":"module"},{"doc":"Our submarine does weird nodes, and we need to extract 2 numbers out of it using bitwise operations. Bitwise operations Well, Elixir has a Bitwise module and I am reaaaaly versed in bitwise operations, so, we will use bitwise operations. Importing modules This exercice was the easiest so far, I had a working solution inside iex in less than 10 minutes. I could refactor this crap, but I guess my time will be better invested in another aspect : structuring and reusing parts of code. Elixir have three methods used for managing reuse: require, and import. And not one of these will help us &quot;require&quot; a file, because it's not needed. Any module in the directory are automatically loaded and usable, on the sole condition the file was compiled beforehand. Mix Mix is a tool for managing compilations, dependencies, etc of an elixir application. I'ts the bundler or the npm of Elixir. Using it is pretty easy and I can shape an application pretty quickly. It have a built-in documentation syntaxe and I will need to investigate this further, I would like to use it for compiling this devblog.","ref":"Day03.html","title":"Day03","type":"module"},{"doc":"","ref":"Day03.html#get_average_for_bit_position/2","title":"Day03.get_average_for_bit_position/2","type":"function"},{"doc":"","ref":"Day03.html#get_least_common_bit/2","title":"Day03.get_least_common_bit/2","type":"function"},{"doc":"","ref":"Day03.html#get_most_common_bit/2","title":"Day03.get_most_common_bit/2","type":"function"},{"doc":"","ref":"Day03.html#select_bit/2","title":"Day03.select_bit/2","type":"function"},{"doc":"","ref":"Day03.html#set_bit/3","title":"Day03.set_bit/3","type":"function"},{"doc":"We will need to play bingo with a giant squid. And we will cheat. I DO BE DUMB This exercice was HELL. Worst, it was hell for nothing. For the first part, I lost at least 1 hour figuring 0 is an available number in bingo, so replacing already picked numbers by 0 on my boards will do wonders when I will need to sum, but it will also make boards finish too early in some situations. For the part two, I derped again, and lost way to much time figuring I need to wait until the last board win before calculating it's score. Using CLI arguments For helping the debug, I created a way to load an alternative input file name (for example inputs/04.example) with Option.parser. options = OptionParser . parse ( System . argv , strict : [ example : :boolean ] ) |&gt; elem ( 0 ) type = if ( options [ :example ] ) , do : &quot;example&quot; , else : &quot;input&quot;","ref":"Day04.html","title":"Day04","type":"module"},{"doc":"","ref":"Day04.html#cross_number_on_board/2","title":"Day04.cross_number_on_board/2","type":"function"},{"doc":"","ref":"Day04.html#draw_board/1","title":"Day04.draw_board/1","type":"function"},{"doc":"","ref":"Day04.html#get_board_score/1","title":"Day04.get_board_score/1","type":"function"},{"doc":"","ref":"Day04.html#get_boards/1","title":"Day04.get_boards/1","type":"function"},{"doc":"","ref":"Day04.html#get_col/2","title":"Day04.get_col/2","type":"function"},{"doc":"","ref":"Day04.html#get_row/2","title":"Day04.get_row/2","type":"function"},{"doc":"","ref":"Day04.html#is_board_completed?/1","title":"Day04.is_board_completed?/1","type":"function"},{"doc":"","ref":"Day04.html#is_row_or_col_completed?/1","title":"Day04.is_row_or_col_completed?/1","type":"function"},{"doc":"We need to draw a map of thermal vents for calcluating the savest route. Part 1 This one is fairly easy on the Part 1. We simply need to &quot;draw&quot; lines and get the number of intersections. So all I need is to interpolates between the two sides of a line and do some reduce/filter. I guess Part2 will be pathfinding or adding oblique lines, so I will need to find a a* package or simply modyfing my interpolation implementation. Part 2 Finally part 2 ask us to add oblique but only full diagonales, so we don't need to modify anythinhg in our implementation, juste removing a filter. Documentation generation Like day 3, let's use quick exercices for learning new stuffs. I read Elixir treat documentation as a first-class citizen, so let's try to use it for writing the devblog.","ref":"Day05.html","title":"Day05","type":"module"},{"doc":"","ref":"Day05.html#calculate_solution/1","title":"Day05.calculate_solution/1","type":"function"},{"doc":"","ref":"Day05.html#draw_line/2","title":"Day05.draw_line/2","type":"function"},{"doc":"","ref":"Day05.html#draw_point/2","title":"Day05.draw_point/2","type":"function"},{"doc":"","ref":"Day05.html#to_coords/1","title":"Day05.to_coords/1","type":"function"},{"doc":"Does lanternfish spawn exponentially quickly ? I don't know but I guess il will be our job to find out ! &quot;Exponentially&quot; generally mean &quot;bad news&quot; This day assignment is... fishy. Solving this with something like String.split -&gt; Integer.parse -&gt; map(0 ? 6 : n - 1) -&gt; sprouting_fish is the obvious solution, but it will fill way to much memory. I will go for a solution with a list (edit: a tuple. We know the final size, it's a tuple.), where I track the number of fish of each age. That's all folks ! My solution work for 80 days, and as expected part 2 ask us to push to 256 days for provoking a OOM. With my implementation I don't have this kind of problems, it's an easy win today.","ref":"Day06.html","title":"Day06","type":"module"},{"doc":"","ref":"Day06.html#grow_fish/1","title":"Day06.grow_fish/1","type":"function"},{"doc":"Crab submarines are really neat underwater vehicles with a quircky way of displacement. How can we align them ? Let's do some maths First part of assignment ask me to calculate a median. Testing it on iex gave me the right answer. Part two ask me to calculate an average and a factorial. Testing it on iex also gave me the right answer. So, let's call it a day, and see you tomorow !","ref":"Day07.html","title":"Day07","type":"module"},{"doc":"","ref":"Day07.html#average/1","title":"Day07.average/1","type":"function"},{"doc":"","ref":"Day07.html#calculate_expensive_fuel_consumption/2","title":"Day07.calculate_expensive_fuel_consumption/2","type":"function"},{"doc":"","ref":"Day07.html#calculate_linear_fuel_consumption/2","title":"Day07.calculate_linear_fuel_consumption/2","type":"function"},{"doc":"","ref":"Day07.html#factorial/1","title":"Day07.factorial/1","type":"function"},{"doc":"","ref":"Day07.html#median/1","title":"Day07.median/1","type":"function"},{"doc":"Today we need to repair a broken seven-segment display. First part was confusing. I started searching how to find which is which number by making comparison of segments, and have done all my preparatory work before reading the end of my assignment. So, I need to find numbers with specific lengths, so a simple filter will do. Let's get real ! Part 2 was as fun as expected ! I find my solution dirty, but I guess I still don't &quot;think&quot; in elixir. Anyway, it works and it was tons of fun !","ref":"Day08.html","title":"Day08","type":"module"},{"doc":"","ref":"Day08.html#extract_0/1","title":"Day08.extract_0/1","type":"function"},{"doc":"","ref":"Day08.html#extract_1/1","title":"Day08.extract_1/1","type":"function"},{"doc":"","ref":"Day08.html#extract_2/1","title":"Day08.extract_2/1","type":"function"},{"doc":"","ref":"Day08.html#extract_3/1","title":"Day08.extract_3/1","type":"function"},{"doc":"","ref":"Day08.html#extract_4/1","title":"Day08.extract_4/1","type":"function"},{"doc":"","ref":"Day08.html#extract_5/1","title":"Day08.extract_5/1","type":"function"},{"doc":"","ref":"Day08.html#extract_6/1","title":"Day08.extract_6/1","type":"function"},{"doc":"","ref":"Day08.html#extract_7/1","title":"Day08.extract_7/1","type":"function"},{"doc":"","ref":"Day08.html#extract_8/1","title":"Day08.extract_8/1","type":"function"},{"doc":"","ref":"Day08.html#extract_9/1","title":"Day08.extract_9/1","type":"function"},{"doc":"","ref":"Day08.html#get_dictionary/1","title":"Day08.get_dictionary/1","type":"function"},{"doc":"","ref":"Day08.html#intersect/2","title":"Day08.intersect/2","type":"function"},{"doc":"","ref":"Day08.html#same_set?/2","title":"Day08.same_set?/2","type":"function"},{"doc":"","ref":"Day08.html#to_signal_note/1","title":"Day08.to_signal_note/1","type":"function"},{"doc":"","ref":"Day08.html#transcript/1","title":"Day08.transcript/1","type":"function"},{"doc":"Today, we need to find the lowest points of a heightmap. Lazy me want to make a simple &quot;get_altitude&quot; and check neighbors of each points, even if I could optimise much further. I hope it will not backfire during part 2. Finding bassins Part 2 ask us to find areas where water will &quot;flow&quot; to the lower points. As we know at leash 1 point per zone (the lower point), we will use an area fill algorithm. Unexpectedly hard The implementation was unexpectedly hard and the result unexpectedly smelly. Clearly my problem here is my usage of tuple and the planning/naming/ordering of my functions. There is still much to learn, and I am looknig forward the end of this advent of code, when my &quot;No tuto&quot; restriction will come off. Elixir is a really good language, definetly the best pick I could have done.","ref":"Day09.html","title":"Day09","type":"module"},{"doc":"","ref":"Day09.html#assign_point_to_bassin/3","title":"Day09.assign_point_to_bassin/3","type":"function"},{"doc":"","ref":"Day09.html#fill_bassin/3","title":"Day09.fill_bassin/3","type":"function"},{"doc":"","ref":"Day09.html#get_altitude/2","title":"Day09.get_altitude/2","type":"function"},{"doc":"","ref":"Day09.html#get_bassin_id/2","title":"Day09.get_bassin_id/2","type":"function"},{"doc":"","ref":"Day09.html#get_lower_points/1","title":"Day09.get_lower_points/1","type":"function"},{"doc":"","ref":"Day09.html#get_neighbors_altitude/2","title":"Day09.get_neighbors_altitude/2","type":"function"},{"doc":"","ref":"Day09.html#get_neighbors_coords/2","title":"Day09.get_neighbors_coords/2","type":"function"},{"doc":"","ref":"Day09.html#is_lower_point?/2","title":"Day09.is_lower_point?/2","type":"function"},{"doc":"Today we need to write a block parser, for sorting lines unfinished or with a syntax error I am getting the hang of recursion Tpday, I am really pleased with my check_syntax method. The firtst implementation I thought about used recursion and not looping, and I think my code is very clear and pleasant. Maybe yesterday was a bitter but much needed lesson : I need to think in elixir, not in ruby/js/whatever and then transtate to elixir. I found new stuff I needed without knowing it Some days ago, I finally understood this &amp;Something functions and how to use them. Yesterday I stumbled upon the &quot;&amp;()&quot; shorthand syntax, it will really help me. Today I found I can store lambdas (or anonymous functions, I don't know what they are for now) in variables, like I could in ruby or javascript. I also found a way to use functions like a pseudo case, and I could make my code way dryer with that. If only I could go back and fix all previous days, I guess my code would be way shorter and understandable.","ref":"Day10.html","title":"Day10","type":"module"},{"doc":"","ref":"Day10.html#check_syntax/2","title":"Day10.check_syntax/2","type":"function"},{"doc":"Today assignment is about making a map of octopus. Again, a great exercice for recursion. Organising functions in modules. My current organisation don't make a really good use of modules. Putting all needed functions in a module was ok for iex debugging (it only lack hot reloading, currently I need to use r Day10 each time for example), but I can do better. Yesterday I needed median and I used it directly from Day07, but it clearly felt wrong. I could have added median and average directly in Enum (could I ? Is monkey patching a thing in elixir ? I mean, modules are complied, right ? I need to investigate this.) or made a module for this. Today, I will not make the same mistake again, and directly make a Map2D from the day with the lava. I can see some of my flaws My elixir code is crippled with problems I will need to address. I will list here what I need to keep in my head for tomorrow. I use tuple when a map would be better for readability I don't have a consistent way to name my functions I use waay too much piping, even when it's not semantically correct I don't use guards enough","ref":"Day11.html","title":"Day11","type":"module"},{"doc":"","ref":"Day11.html#day_pass/1","title":"Day11.day_pass/1","type":"function"},{"doc":"","ref":"Day11.html#flash/2","title":"Day11.flash/2","type":"function"},{"doc":"","ref":"Day11.html#gain_energy/2","title":"Day11.gain_energy/2","type":"function"},{"doc":"Today I have to explore an interconnected tree for all possible paths. I already have a solution with recursion in my head, and I think it will go smoothly defstruct Today assignment was nice, and I am pleased by my solution. NOt much to say about it, so I will talk about one major discovery I found today while reading Kernel source code : Struct. Struct in elixir are globally struct, like in ruby for example. This is the missing piece I needed for replacing my (bad) usage of tuples. I don't have any reason to use them today, but have some really good usage for them for map_2d ! I hope I will need to work on this module again soon. Unfortunately, next week will be loaded way to much, I already know I couldn't be diligent.","ref":"Day12.html","title":"Day12","type":"module"},{"doc":"","ref":"Day12.html#fetch_room/2","title":"Day12.fetch_room/2","type":"function"},{"doc":"","ref":"Day12.html#filter_forbidden_rooms/3","title":"Day12.filter_forbidden_rooms/3","type":"function"},{"doc":"","ref":"Day12.html#seek_paths/3","title":"Day12.seek_paths/3","type":"function"},{"doc":"","ref":"Day12.html#seek_paths/4","title":"Day12.seek_paths/4","type":"function"},{"doc":"Santa's elven have failed hard (like any other year) and we need to get the sleigh keys back from the bottom of the ocean. And for this we will need to read a file, parse and loop over values intil we get them back !","ref":"readme.html","title":"ADVENT OF CODE 2021","type":"extras"},{"doc":"Advent of code is one of my favorit part of the year for discovering new technologies or focusing hard on things I know but don't use as much as I want. Last year I've done all the exercices in Neovim, it was fun and I really regret not having kept a devblog. This year, for sake of keeping traces and don't regret it later I will keep trace of everything I do !","ref":"readme.html#why-this-devblog","title":"ADVENT OF CODE 2021 - Why this devblog","type":"extras"},{"doc":"This year, my choice is... Elixir ! As I write today, I'v never touched Elixir. I know it's functionnal, it run on Erlang VM, and that's pretty much it. So let's start with Day01 !","ref":"readme.html#language-of-choice-for-this-year-elixir","title":"ADVENT OF CODE 2021 - Language of choice for this year : Elixir","type":"extras"},{"doc":"Blog posts are written on the day I complete a challenge, and generally at the same time, do don't be triggered by present/past/futur mixing of the phrases. I will make a iron rull about letting the solutions as they are. I have already done some refactoring and I guess I will do some other, but it will only affect meta and organisations. Dirty solutions will remain dirty, but by the end of the challenge I hope my progress will be clear.","ref":"readme.html#notes-about-this-devblog-repo","title":"ADVENT OF CODE 2021 - Notes about this devblog/repo","type":"extras"}]